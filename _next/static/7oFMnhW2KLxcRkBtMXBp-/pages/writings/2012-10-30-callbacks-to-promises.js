(window.webpackJsonp=window.webpackJsonp||[]).push([["4525"],{"3Q3I":function(e,n,t){"use strict";t.r(n),t.d(n,"title",function(){return s}),t.d(n,"default",function(){return b});var a=t("z3IF"),o=t("2Fjn"),r=(t("mXGw"),t("SAVP")),i=t("SGno"),s='"callbacks to promises" with javascript',c={title:s},l=i.a;function b(e){var n=e.components,t=Object(o.a)(e,["components"]);return Object(r.b)(l,Object(a.a)({},c,t,{components:n,mdxType:"MDXLayout"}),Object(r.b)("p",null,"I prefer to use promises instead of callbacks for structuring async code in JS.\nThe main reason is ",Object(r.b)("em",{parentName:"p"},"composability")," â€” callbacks do not compose well but promises\ndo."),Object(r.b)("p",null,"The simple case when you need to synchronize on two or more parallel async\noperations becomes a nightmare with callbacks but can be easily done with\npromises just with a simple combinator."),Object(r.b)("p",null,"Compare callback based-solution"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"googleSearched = undefined\nbingSearched = undefined\n\nsearch = (engine, q, cb) ->\n  $.ajax(url: engine, success: cb)\n\nsearch 'bing', 'js', (r) ->\n  if googleSearched\n    processResults(r, googleSearched)\n  else\n    bingSearched = r\n\nsearch 'google', 'js', (r) ->\n  if bingSearched\n    processResults(bingSearched, r)\n  else\n    googleSearched = r\n\nprocessResults(bingResults, googleResults) ->\n  ...\n")),Object(r.b)("p",null,"with one that uses promises"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"search = (engine, q, cb) ->\n  $.ajax(url: engine)\n\n$.when(search('bing', 'js'), search('google', 'js')).done (r) ->\n  [bingResults, googleResults] = r\n  ...\n")),Object(r.b)("p",null,"Here I used ",Object(r.b)("inlineCode",{parentName:"p"},"$.when(promises)")," function from jQuery which returns promise value\nwhich resolves only when every of the passed promises are resolved."),Object(r.b)("p",null,"It won't be difficult to think of any other case where transformation of the\ncode from callback-based \"pyramids\" to promises' combination would yield a huge\nsimplifications to code."),Object(r.b)("p",null,"But the problem is that a lot of code is already written using callbacks so how\nto take the advantage of it and still use clean and simple promises' combinators\nlike ",Object(r.b)("inlineCode",{parentName:"p"},"$.when()"),"? The solution I use is a simple function"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"cont = (func) ->\n  ->\n    deferred = $.Deferred()\n    args = $.makeArray(arguments)\n    args.splice 0, 0, (result, error) ->\n      if error != undefined\n        deferred.reject(error)\n      else\n        deferred.resolve(result)\n    func.apply(this, args)\n    deferred\n")),Object(r.b)("p",null,"It wraps function ",Object(r.b)("inlineCode",{parentName:"p"},"func")," into anonymous function which returns promise and adds\nadditional argument I usually call ",Object(r.b)("inlineCode",{parentName:"p"},"next")," which aims to resolve or reject\nreturned promise. I use it like"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"$.fn.promiseFadeIn = cont (next, duration) ->\n  this.fadeIn(duration, next)\n\n$.fn.promiseFadeOut = cont (next, duration) ->\n  this.fadeOut(duration, next)\n")),Object(r.b)("p",null,"Here I extended jQuery with ",Object(r.b)("inlineCode",{parentName:"p"},"promiseFadeIn")," and ",Object(r.b)("inlineCode",{parentName:"p"},"promiseFadeOut")," methods which\nare similar to original ",Object(r.b)("inlineCode",{parentName:"p"},"fadeIn")," and ",Object(r.b)("inlineCode",{parentName:"p"},"fadeOut")," but instead return promises which\nwill be resolved on completion instead of firing callbacks."),Object(r.b)("p",null,"Now you can synchronize on several animations which execute in parallel like\nthis"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"fadeIn = $('.left').promiseFadeIn(500)\nfadeout = $('.right').promiseFadeOut(500)\n$.when(fadeIn, fadeOut).done ->\n  # animations are done, do something else\n")),Object(r.b)("p",null,"Another interesting example is how to construct a promise which resolves after\nsome delay, the so-called ",Object(r.b)("inlineCode",{parentName:"p"},"setTimeout()")," twin"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"delay = cont (next, timeout) ->\n  setTimeout(next, timeout)\n")),Object(r.b)("p",null,"or just simply"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"delay = cont setTimeout\n")),Object(r.b)("p",null,"The usage is straightforward"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"delay(500).done ->\n  ...\n")),Object(r.b)("p",null,"In this case it differs just a little from raw ",Object(r.b)("inlineCode",{parentName:"p"},"setTimeout()")," usage but you\nreally can use it in any existent promises' combinators like ",Object(r.b)("inlineCode",{parentName:"p"},"$.when()"),"."))}b.isMDXComponent=!0},pauh:function(e,n,t){(window.__NEXT_P=window.__NEXT_P||[]).push(["/writings/2012-10-30-callbacks-to-promises",function(){var e=t("3Q3I");return{page:e.default||e}}])}},[["pauh","5d41","9da1"]]]);