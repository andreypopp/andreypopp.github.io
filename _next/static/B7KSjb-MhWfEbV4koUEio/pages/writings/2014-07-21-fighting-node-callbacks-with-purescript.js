(window.webpackJsonp=window.webpackJsonp||[]).push([["9128"],{F6wV:function(e,n,t){(window.__NEXT_P=window.__NEXT_P||[]).push(["/writings/2014-07-21-fighting-node-callbacks-with-purescript",function(){var e=t("OP5t");return{page:e.default||e}}])},OP5t:function(e,n,t){"use strict";t.r(n),t.d(n,"title",function(){return l}),t.d(n,"default",function(){return p});var a=t("z3IF"),i=t("2Fjn"),r=(t("mXGw"),t("SAVP")),o=t("SGno"),l="Fighting Node callback hell with PureScript",c={title:l},b=o.a;function p(e){var n=e.components,t=Object(i.a)(e,["components"]);return Object(r.b)(b,Object(a.a)({},c,t,{components:n,mdxType:"MDXLayout"}),Object(r.b)("p",null,"Recently ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/visionmedia"}),"TJ Holowaychuk"),", one of the most active persons in Node.js\necosystem said ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://medium.com/code-adventures/farewell-node-js-4ba9e7f3e52b"}),"good bye to Node.js"),". He switched to Go."),Object(r.b)("p",null,"As one of the reasons he mentions:"),Object(r.b)("blockquote",null,Object(r.b)("p",{parentName:"blockquote"},"In the past week I’ve rewritten a relatively large distributed system in Go, and\nit’s robust, performs better, it’s easier to maintain, and has better test\ncoverage since synchronous code is generally nicer and simpler to work with.")),Object(r.b)("p",null,"The Go programming language has the notion of goroutines, a lightweight\nthreading mechanism which allows to express program logic in a synchronous\ncontrol flow even if underneath it uses non-blocking I/O."),Object(r.b)("p",null,"This is in contrast to Node.js where you need to control an asynchronous\nexecution of I/O explicitly by passing callbacks around:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"function readWriteFile(filenameIn, filenameOut, cb) {\n  fs.readFile(filenameIn, function(err, contents) {\n    if (err) {\n      return cb(err)\n    }\n    fs.writeFile(filenameOut, contents, function(err) {\n      if (err) {\n        return cb(err)\n      }\n      cb(null)\n    })\n  })\n}\n")),Object(r.b)("p",null,"Function above reads contents of ",Object(r.b)("inlineCode",{parentName:"p"},"filenameIn")," and writes it into ",Object(r.b)("inlineCode",{parentName:"p"},"filenameOut"),".\nSilly example, but it illustrates well how such a simple task can become\nunreasonably complex when expressing with callbacks."),Object(r.b)("p",null,"But callback-based programming is even worse at scale because it forces you to\nstructure and decompose your code around how you do an I/O and not how your\napplication domain requires."),Object(r.b)("p",null,"What if instead of using callbacks to express program we would do it using\nsynchronous-looking code and then some source transformation would compile it\nback to callback-based code?"),Object(r.b)("p",null,"An example:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"readWriteFile filenameIn filenameOut = do\n  contents <- readFile filenameIn\n  writeFile contents\n")),Object(r.b)("p",null,"Code above is not JavaScript, it's ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"http://purescript.org"}),"PureScript"),". The point is\nthat it looks as simple as the task it performs."),Object(r.b)("p",null,"PureScript is a strictly typed programming language which compiles to\nJavaScript. It looks like and inspired by Haskell."),Object(r.b)("p",null,"If you don't know Haskell, don't worry, the code in the blog post is simple\nenough to understand without any background in Haskell. Though if you know it\nyou'd probably find my explanations to be naive."),Object(r.b)("p",null,"This blog post isn't meant to be an introduction to PureScript. What we going to\ndo instead is to show how to build a library which would allow to interface with\nasynchronous Node.js code. Instead of callback-based interface we are going to\nprovide a way to write synchronous-looking code, like ",Object(r.b)("inlineCode",{parentName:"p"},"readWriteFile")," function\nabove."),Object(r.b)("p",null,"An example which defines an interface for Node's ",Object(r.b)("inlineCode",{parentName:"p"},"fs.readFile")," and\n",Object(r.b)("inlineCode",{parentName:"p"},"fs.writeFile")," functions:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"import Node.Thunk\n\nforeign import fs \"var fs = require('fs');\" :: {\n  readFile :: ThunkFn2 String String,\n  writeFile :: ThunkFn3 String String String,\n  }\n\nreadFile = runThunkFn2 fs.readFile\nwriteFile = runThunkFn3 fs.writeFile\n")),Object(r.b)("p",null,"An interesting point to note is that PureScript offers nothing designed\nspecifically to deal with async operations. Yet all the features we are going to\nuse are general enough to so we can express asynchronous computations in a\nconcise manner."),Object(r.b)("h2",null,"Implementation"),Object(r.b)("p",null,"We are going to use a couple of predefined PureScript modules. Some of them are\npart of the standard library but some should be installed via ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"http://bower.io"}),"bower")," package\nmanager:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"% bower install purescript-global purescript-either\n")),Object(r.b)("p",null,"Let's start with some imports:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"module Node.Thunk where\n\nimport Control.Monad.Eff\nimport Data.Either\nimport Global\n")),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"Control.Monad.Eff")," provides ",Object(r.b)("inlineCode",{parentName:"p"},"Eff")," data type which PureScript uses to represent\nan effectful computation. This is similar to ",Object(r.b)("inlineCode",{parentName:"p"},"IO")," in Haskell but actually more\npowerful and typesafe. You can read more on ",Object(r.b)("inlineCode",{parentName:"p"},"Eff")," in a ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"http://www.purescript.org/posts/Eff-Monad/"}),"blog post")," on\nPureScript blog."),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"Data.Either")," provides ",Object(r.b)("inlineCode",{parentName:"p"},"Either")," data type which represent either a value or an\nerror. It is similar to Haskell's ",Object(r.b)("inlineCode",{parentName:"p"},"Either"),"."),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"Global")," provides ",Object(r.b)("inlineCode",{parentName:"p"},"Error")," data type which maps to JavaScript ",Object(r.b)("inlineCode",{parentName:"p"},"Error"),"."),Object(r.b)("h3",null,"Representing Node async functions"),Object(r.b)("p",null,"We want a way to represent values (or errors) which will be available after some\nasync I/O is done. We want them to be typed by the type of the result:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"foreign import data Thunk :: * -> *\n")),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"* -> *")," means that ",Object(r.b)("inlineCode",{parentName:"p"},"Thunk")," is not a simple data type, but a data type which\ncan be parametrized by another data type."),Object(r.b)("p",null,"For example, ",Object(r.b)("inlineCode",{parentName:"p"},"Thunk Number")," is a data type which represents a number which will\nbe available at some moment in the future."),Object(r.b)("p",null,"Note that implementation of ",Object(r.b)("inlineCode",{parentName:"p"},"Thunk")," is opaque to PureScript compiler. We are\ngoing to define a couple of FFI functions which will represent primitive\noperations a programmer can perform on ",Object(r.b)("inlineCode",{parentName:"p"},"Thunk")," values."),Object(r.b)("p",null,"We should still define how ",Object(r.b)("inlineCode",{parentName:"p"},"Thunk")," will be represented at runtime."),Object(r.b)("p",null,"Let's define values of ",Object(r.b)("inlineCode",{parentName:"p"},"Thunk")," to be functions which take a single argument, a\ncallback of the shape ",Object(r.b)("inlineCode",{parentName:"p"},"cb(err, result)"),". That way thunks are perfectly valid\nNode.js asynchronous functions, like ",Object(r.b)("inlineCode",{parentName:"p"},"process.nextTick(cb)"),"."),Object(r.b)("p",null,"Let's define FFI primitives which help us create ",Object(r.b)("inlineCode",{parentName:"p"},"Thunk")," values:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),'foreign import resolve\n  "function resolve(a) { return function(cb) { cb(null, a); } }"\n  :: forall a. a -> Thunk a\n\nforeign import reject\n  "function resolve(err) { return function(cb) { cb(err); } }"\n  :: forall a. Error -> Thunk Unit\n')),Object(r.b)("p",null,"As you see ",Object(r.b)("inlineCode",{parentName:"p"},"resolve")," and ",Object(r.b)("inlineCode",{parentName:"p"},"reject")," return a thunk, a ",Object(r.b)("inlineCode",{parentName:"p"},"function(cb) {...}")," value,\nas we agreed."),Object(r.b)("p",null,"We also need a function which would allow to get the wrapped value out of\n",Object(r.b)("inlineCode",{parentName:"p"},"Thunk"),":"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),'foreign import runThunk\n  "function runThunk(a) {                                          \\\n  \\  return function(handler) {                                    \\\n  \\    return function() {                                         \\\n  \\      return a(function(err, result) {                          \\\n  \\        if (err) {                                              \\\n  \\          handler(PS.Data_Either.Left(err))();                  \\\n  \\        } else {                                                \\\n  \\          handler(PS.Data_Either.Right(result))();              \\\n  \\        }                                                       \\\n  \\      });                                                       \\\n  \\    };                                                          \\\n  \\  };                                                            \\\n  \\}"\n  :: forall a b eff eff2.\n  Thunk a\n  -> (Either Error a -> Eff (eff) b)\n  -> Eff (eff2) Unit\n')),Object(r.b)("p",null,"The type signature may seems a little complex for novice PureScripters but it is\nactually quite simple. What it says is that ",Object(r.b)("inlineCode",{parentName:"p"},"runThunk")," gets a thunk and a\nfunction which accepts either an error or a thunk's value and executes an\naction."),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"runThunk")," being a PureScript function of two arguments is represented in\nJavaScript as a function of a single argument which returns another function\nwhich takes the second argument. This is because functions in PureScript are\ncurried."),Object(r.b)("p",null,"Another interesting point to note is that PureScript represents values of ",Object(r.b)("inlineCode",{parentName:"p"},"Eff"),"\nas functions with no arguments: ",Object(r.b)("inlineCode",{parentName:"p"},"function() {...}"),". This is what ",Object(r.b)("inlineCode",{parentName:"p"},"runThunk"),"\nreturns when it receives its two arguments."),Object(r.b)("p",null,"We already can define a super simple program which operates on thunks:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),'main = do\n  let value = resolve 1\n  runThunk value handle\n    where\n  handle (Left err) = print ("Error: " ++ (show err))\n  handle (Right result) = print ("Result: " ++ (show result))\n')),Object(r.b)("p",null,"This is not yet useful though. We need to define more primitve FFI operations on\nthunks before we can write real world programs with them."),Object(r.b)("h3",null,"Transforming thunks"),Object(r.b)("p",null,"Another useful primitive operation on thunks is ",Object(r.b)("inlineCode",{parentName:"p"},"fmap"),". It defines how to\ntransform a thunk by producing another thunk with a transformed value."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),'foreign import fmap\n  "function fmap(f) {                                              \\\n  \\  return function(a) {                                          \\\n  \\    return function(cb) {                                       \\\n  \\      a(function(err, result) {                                 \\\n  \\        if (err) return cb(err);                                \\\n  \\        try {                                                   \\\n  \\          result = f(result);                                   \\\n  \\        } catch (err) {                                         \\\n  \\          return cb(err);                                       \\\n  \\        }                                                       \\\n  \\        cb(null, result);                                       \\\n  \\      });                                                       \\\n  \\    };                                                          \\\n  \\  };                                                            \\\n  \\}"\n  :: forall a b. (a -> b) -> Thunk a -> Thunk b\n')),Object(r.b)("p",null,'Its type reads as "given a function and a thunk we can get another thunk with\nthis function applied to a result of the former thunk".'),Object(r.b)("p",null,"Again, a not yet so useful example:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"two = resolve 2\nfour = fmap (\\n -> n * 2) two\n")),Object(r.b)("h3",null,"Chaining computations on thunks"),Object(r.b)("p",null,"Next thing is to define an operation of chaining computations on thunks:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),'foreign import bind\n  "function bind(a) {                                              \\\n  \\  return function(f) {                                          \\\n  \\    return function(cb) {                                       \\\n  \\      a(function(err, a) {                                      \\\n  \\        if(err) return cb(err);                                 \\\n  \\        try {                                                   \\\n  \\          f(a)(cb);                                             \\\n  \\        } catch(err) {                                          \\\n  \\          return cb(err);                                       \\\n  \\        }                                                       \\\n  \\      });                                                       \\\n  \\    }                                                           \\\n  \\  }                                                             \\\n  \\}"\n  :: forall a b. Thunk a -> (a -> Thunk b) -> Thunk b\n')),Object(r.b)("p",null,"The type of signature of ",Object(r.b)("inlineCode",{parentName:"p"},"bind")," is similar to ",Object(r.b)("inlineCode",{parentName:"p"},"fmap")," in a sense that both take a\nthunk and a transformation function as arguments and produce another thunk. The\ndifference is that the transformation produces a thunk value too."),Object(r.b)("p",null,"That effectively means that we can define async computations based on the\nresults of previous async computations."),Object(r.b)("p",null,"Now we finally can write some meaningful code with thunks:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"readWriteFile filenameIn filenameOut =\n  let contentThunk = readFile filenameIn in\n  bind contentThunk (\\contents -> writeFile filenameOut contents)\n")),Object(r.b)("p",null,"OK, we can't compile it yet because we don't know what ",Object(r.b)("inlineCode",{parentName:"p"},"readFile")," and\n",Object(r.b)("inlineCode",{parentName:"p"},"writeFile")," means but this example illustrates the point of ",Object(r.b)("inlineCode",{parentName:"p"},"bind")," — we can\nexecute ",Object(r.b)("inlineCode",{parentName:"p"},"writeFile")," only after the result of ",Object(r.b)("inlineCode",{parentName:"p"},"contentThunk")," becomes available."),Object(r.b)("h3",null,"Running thunks in parallel"),Object(r.b)("p",null,"Given that all Node.js I/O is non-blocking we can start execution of two or more\nactions in parallel and the collect the result eventually."),Object(r.b)("p",null,"We should provide the same feature in PureScript. For that we would need another\nFFI primitive:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),'foreign import app\n  "function app(f) {                                               \\\n  \\  return function(a) {                                          \\\n  \\    return function(cb) {                                       \\\n  \\      var latch = 2;                                            \\\n  \\      var fVal, aVal, val;                                      \\\n  \\                                                                \\\n  \\      f(function(err, f) {                                      \\\n  \\        if (err && latch !== 0) {                               \\\n  \\          latch = 0;                                            \\\n  \\          return cb(err);                                       \\\n  \\        }                                                       \\\n  \\        latch = latch - 1;                                      \\\n  \\        fVal = f;                                               \\\n  \\        if (latch === 0) {                                      \\\n  \\          try {                                                 \\\n  \\            val = fVal(aVal);                                   \\\n  \\          } catch(err) {                                        \\\n  \\            return cb(err);                                     \\\n  \\          }                                                     \\\n  \\          cb(null, val);                                        \\\n  \\        }                                                       \\\n  \\      });                                                       \\\n  \\                                                                \\\n  \\      a(function(err, a) {                                      \\\n  \\        if (err && latch !== 0) {                               \\\n  \\          latch = 0;                                            \\\n  \\          return cb(err);                                       \\\n  \\        }                                                       \\\n  \\        latch = latch - 1;                                      \\\n  \\        aVal = a;                                               \\\n  \\        if (latch === 0) {                                      \\\n  \\          try {                                                 \\\n  \\            val = fVal(aVal);                                   \\\n  \\          } catch(err) {                                        \\\n  \\            return cb(err);                                     \\\n  \\          }                                                     \\\n  \\          cb(null, val);                                        \\\n  \\        }                                                       \\\n  \\      });                                                       \\\n  \\    };                                                          \\\n  \\  };                                                            \\\n  \\}"\n  :: forall a b. Thunk (a -> b) -> Thunk a -> Thunk b\n')),Object(r.b)("p",null,"Again, the type signature is similar to ",Object(r.b)("inlineCode",{parentName:"p"},"fmap")," but now the function itself is a\nthunk."),Object(r.b)("p",null,"How to use ",Object(r.b)("inlineCode",{parentName:"p"},"app")," to execute thunks in parallel? Let's define a simple combinator\n",Object(r.b)("inlineCode",{parentName:"p"},"par")," which builds up on ",Object(r.b)("inlineCode",{parentName:"p"},"app"),":"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"par :: forall a b. Thunk a -> Thunk b -> Thunk {a :: a, b :: b}\npar a b =\n  app (app (resolve \\a -> \\b -> {a: a, b: b}) a) b\n")),Object(r.b)("p",null,"I think it's useful to think of the first argument of the ",Object(r.b)("inlineCode",{parentName:"p"},"app")," as a function\nwhich eventually collects the result. If this function returns another function,\nwe can compose it further via ",Object(r.b)("inlineCode",{parentName:"p"},"app"),". That's what ",Object(r.b)("inlineCode",{parentName:"p"},"par")," combinator essentially does."),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"par")," combinator can be use now to read two files concurrently:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"readTwoFiles filenameA filenameB =\n  par (readFile filenameA) (readFile filenameB)\n")),Object(r.b)("p",null,"The result of this computation would be the record with fields ",Object(r.b)("inlineCode",{parentName:"p"},"a")," and ",Object(r.b)("inlineCode",{parentName:"p"},"b")," which\nhold the contents of ",Object(r.b)("inlineCode",{parentName:"p"},"filenameA")," and ",Object(r.b)("inlineCode",{parentName:"p"},"filenameB")," correspondingly."),Object(r.b)("h3",null,"Type classes"),Object(r.b)("p",null,"Now that we have a powerful set of primitive operations on top of thunks we can\nuse them to compose useful programs."),Object(r.b)("p",null,"But the way ",Object(r.b)("inlineCode",{parentName:"p"},"bind"),", the main combinator for computations, works now doesn't\nreally much differ from what we have in JavaScript — we are still programming by\npassing functions-callbacks around."),Object(r.b)("p",null,"To fix this PureScript suggest that we can use ",Object(r.b)("em",{parentName:"p"},"do-notation"),", a way to write\nsequential computations. The example at the start of the blog post uses ",Object(r.b)("inlineCode",{parentName:"p"},"do"),"\nkeyword and so it uses do-notation:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"readWriteFile filenameIn filenameOut = do\n  contents <- readFile filenameIn\n  writeFile contents\n")),Object(r.b)("p",null,"But to make this happen we need our ",Object(r.b)("inlineCode",{parentName:"p"},"Thunk")," data type to be a monad."),Object(r.b)("p",null,"If you don't know what monad is, just don't worry. In this context it means that\nwe need a way to sequentially compose computations on thunks. We already can do\nthis via ",Object(r.b)("inlineCode",{parentName:"p"},"bind")," combinator."),Object(r.b)("p",null,"If you want a thoughtful introduction into what monads, I suggest reading\n",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"http://www.haskell.org/haskellwiki/Typeclassopedia#Monad"}),"Typeclassopedia"),"."),Object(r.b)("p",null,"Anyway, let's proceed and define instances for ",Object(r.b)("inlineCode",{parentName:"p"},"Thunk")," data type."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"instance thunkFunctor :: Functor Thunk where\n  (<$>) = fmap\n\ninstance thunkApply :: Apply Thunk where\n  (<*>) = app\n\ninstance thunkApplication :: Applicative Thunk where\n  pure = resolve\n\ninstance thunkBind :: Bind Thunk where\n  (>>=) = bind\n\ninstance thunkMonad :: Monad Thunk\n")),Object(r.b)("p",null,"What we did above is we simply assigned new names to ",Object(r.b)("inlineCode",{parentName:"p"},"resolve"),", ",Object(r.b)("inlineCode",{parentName:"p"},"fmap"),", ",Object(r.b)("inlineCode",{parentName:"p"},"bind"),"\nand ",Object(r.b)("inlineCode",{parentName:"p"},"app")," functions and nothing more."),Object(r.b)("p",null,"This finally enables do-notation for computations on thunks, so we can write\nthem with synchronous-looking code:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"download url filename = do\n  contents <- getURL url\n  writeFile filename contents\n")),Object(r.b)("p",null,"Of course the fact that ",Object(r.b)("inlineCode",{parentName:"p"},"Thunk")," is a monad automatically makes every function\nwhich deals with monads compatible with thunks. The same holds for functors and\napplicatives."),Object(r.b)("p",null,"Given the new name for ",Object(r.b)("inlineCode",{parentName:"p"},"app")," we can rewrite our ",Object(r.b)("inlineCode",{parentName:"p"},"par")," combinator above can be\ndefined in a more concise way:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"par a b =\n  let collect a b = {a: a, b: b} in\n  pure collect <*> a <*> b\n")),Object(r.b)("h3",null,"Epilogue"),Object(r.b)("p",null,"The library described here is ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/andreypopp/purescript-node-thunk"}),"available on GitHub"),"."),Object(r.b)("p",null,"The point of this blog post is not to convince you that PureScript offers an\nexclusive solution to callback hell in Node.js. This is not true."),Object(r.b)("p",null,"The next specification of JavaScript, ES6, bring ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*"}),"generators")," into the\nlanguage which would allow to write synchronous-looking code for async\ncomputations. ES7, the next iteration is even considering adding\n",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/lukehoban/ecmascript-asyncawait"}),"async/await")," mechanism which targeted specifically to solve the\nproblem of writing asynchronous code in JavaScript."),Object(r.b)("p",null,"Instead, I wanted to highlight that well-designed language such as PureScript,\nwhich provides a set of general orthogonal abstractions, can be used to attack\nsuch non-trivial problems as expressing async computations."),Object(r.b)("p",null,"I think, another feature of PureScript I highlighted in this blog post is the\nsimple and powerful FFI. As you can see PureScript isn't the thing in itself. It\ncan interface with any JavaScript code and such an interface can be made\nidiomatically close to the PureScript without much boilerplate."),Object(r.b)("p",null,"Besides that PureScript has other great features. I especially enjoy extensible\nrecords and effect system."))}p.isMDXComponent=!0}},[["F6wV","5d41","9da1"]]]);