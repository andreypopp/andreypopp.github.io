(window.webpackJsonp=window.webpackJsonp||[]).push([["6743"],{hkSV:function(e,n,t){"use strict";t.r(n),t.d(n,"title",function(){return b}),t.d(n,"default",function(){return m});var a=t("z3IF"),p=t("2Fjn"),r=(t("mXGw"),t("SAVP")),o=t("SGno"),b="О свойствах (property) в Python",l={title:b},c=o.a;function m(e){var n=e.components,t=Object(p.a)(e,["components"]);return Object(r.b)(c,Object(a.a)({},l,t,{components:n,mdxType:"MDXLayout"}),Object(r.b)("p",null,"В Python, есть такая штука, как ",Object(r.b)("em",{parentName:"p"},"свойства (property)")," -- это объекты, которые\nреализуют ",Object(r.b)("em",{parentName:"p"},Object(r.b)("a",Object(a.a)({parentName:"em"},{href:"http://docs.python.org/reference/datamodel.html#descriptors"}),"descriptor")),"-протокол и позволяют проделывать\nследующее:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),'class Person(object):\n\n    def __init__(self, first_name, last_name):\n        self.first_name = first_name\n        self.last_name = last_name\n\n    @property\n    def full_name(self):\n        return " ".join([self.first_name, self.last_name])\n\nperson = Person("Andrey", "Popp")\nperson.full_name # "Andrey Popp"\n')),Object(r.b)("p",null,"Это реализация ",Object(r.b)("em",{parentName:"p"},"attribute getter/setter")," шаблона. То есть, обращаюсь к\n",Object(r.b)("inlineCode",{parentName:"p"},"full_name"),' как к аттрибуту, мы неявно вызываем соответствующий метод и его\nрезультат как бы становится значением аттрибута.  Почему "как бы"? Потому что\nон будет заново вычисляться при каждом обращении к ',Object(r.b)("inlineCode",{parentName:"p"},"full_name"),"."),Object(r.b)("p",null,"Я стараюсь никогда не использовать свойства, в тех случаях, когда для их\nвычисления приходится производить какие-то побочные эффекты, будь-то I/O или\nдаже просто изменение какой-нибудь структуры данных."),Object(r.b)("p",null,"Операция обращения к аттрибуту (а именно так выглядит работа с ",Object(r.b)("inlineCode",{parentName:"p"},"property"),') по\nсвоей семантике должна быть "дешёвой". Со свойствами можно наворотить следующее\n-- представьте себе, что вы, находясь в консоли Python и обращаетесь к некоему\nаттрибуту ',Object(r.b)("inlineCode",{parentName:"p"},"myobj.some_info"),", в результате чего отправляется запрос в БД и\nвычисление свойства происходит в течении ",Object(r.b)("inlineCode",{parentName:"p"},"n")," секунд -- крайне неприятно."),Object(r.b)("p",null,"Одна из библиотек, с которыми я работал и которая не следует вышеупомянутой\nрекомендации -- SQLAlchemy. Там можно настроить маппинг таблиц на модели таким\nобразом, что при обращении к свойствам последних их значения будут\nзапрашиваться из БД отдельным запросом. Получается если обратиться к такому\nсвойству в цикле из 100 итераций, то будет сделано 100 отдельных запросов к БД\nи при этом, программист читающий код, может этого совершенно не заметить."),Object(r.b)("p",null,"Отсюда вердикт -- если для вычисления свойства нужно произвести побочные\nэффекты, то лучше сделать это свойство методом."),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"P.S. Кстати, аналогичное суждение верно и в языках на подобии Scala, где можно\nопустить ",Object(r.b)("inlineCode",{parentName:"em"},"()")," при вызове функций, которые не принимают никаких параметров --\nя считаю, что если функция производит некие побочные эффекты, то ",Object(r.b)("inlineCode",{parentName:"em"},"()")," после\nеё вызова необходимо оставить.")))}m.isMDXComponent=!0},u9XY:function(e,n,t){(window.__NEXT_P=window.__NEXT_P||[]).push(["/writings/2010-07-23-python-property",function(){var e=t("hkSV");return{page:e.default||e}}])}},[["u9XY","5d41","9da1"]]]);