(window.webpackJsonp=window.webpackJsonp||[]).push([["5cf1"],{Ao4s:function(e,n,t){"use strict";t.r(n),t.d(n,"title",function(){return c}),t.d(n,"default",function(){return u});var o=t("z3IF"),a=t("2Fjn"),r=(t("mXGw"),t("SAVP")),i=t("SGno"),c='Node.js: "domain-local" storage',s={title:c},l=i.a;function u(e){var n=e.components,t=Object(a.a)(e,["components"]);return Object(r.b)(l,Object(o.a)({},s,t,{components:n,mdxType:"MDXLayout"}),Object(r.b)("p",null,"One of the recent additions to the Node.js is ",Object(r.b)("a",Object(o.a)({parentName:"p"},{href:"http://nodejs.org/api/domain.html"}),"domains"),"."),Object(r.b)("p",null,"Basically domains provide a way to define a common error handling context for a\ngroup of operations — if some error deep inside a nested callback is thrown then\ncorresponding domain will receive it and perform needed cleanup operations."),Object(r.b)("p",null,"It eliminates a lot of burden from an usual error handling routine by allowing\nnot to passthrough every error returned from an async operation but simply\nto throw it:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{}),"var domain = require('domain').create();\nvar fs = require('fs');\n\ndomain.run(function() {\n  fs.readFile('non-existent-file', function(err, data) {\n    if (err) throw err;\n    // process data\n  });\n});\n\ndomain.on('error', function() {\n  // do some cleanup\n  process.exit(1);\n});\n")),Object(r.b)("p",null,'But for what kind of "group of operations" you should create a new domain?\nUsually such a group represents some kind of a logically sound "transaction"\nsuch as a handling of a single HTTP request in a server process or an actual\ndatabase transaction.'),Object(r.b)("p",null,"What's also usual for such \"groups of operations\" is that they usually have to\naccess some specific data — inside a database transaction you certainly would\nlike to do all database interactions through the single connection. An obvious\nway to handle this is to pass such data as function arguments but, for my taste,\nit's a lot of boilerplate."),Object(r.b)("h2",null,"Domain context"),Object(r.b)("p",null,"Enter ",Object(r.b)("a",Object(o.a)({parentName:"p"},{href:"https://github.com/andreypopp/domain-context"}),"domain-context"),", an npm package which provides a way to associate some\ndata with a given domain and then manage its cleanup, error handling and access."),Object(r.b)("p",null,"The basic example would be:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{}),"var context = require('domain-context');\n\nvar lifecycle = {\n  context: function() {\n    // provide a context for this domain\n    return {connection: new pg.Client(...)};\n  },\n  cleanup: function(context) {\n    // commit the transaction on success\n    context.connection.query('commit');\n    context.connection.end();\n  },\n  onError: function(err, context) {\n    // rollback the transaction on erro\n    context.connection.query('rollback');\n    context.connection.end();\n  }\n};\n\n// run a function in a new domain with a given lifecycle\nvar domain = context.runInNewDomain(lifecycle, function() {\n\n  createUser('andreypopp' function(err, user) {\n    if (err) throw err\n\n    confirmUserEmail('andreypopp', function(err, confirmed) {\n      if (err) throw err\n      // ...\n    });\n  });\n});\n")),Object(r.b)("p",null,"Now if we would like to ",Object(r.b)("inlineCode",{parentName:"p"},"createUser")," and ",Object(r.b)("inlineCode",{parentName:"p"},"confirmUserEmail")," to participate in a\nsingle transaction we should use a single database connection to perform those\nactions. The way we do this is we query the connection from the current context:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{}),"var createUser = function(name, cb) {\n  // will use a connection from a context\n  context.get('connection').query('insert into ...', cb);\n};\n\nvar confirmUserEmail = function(name, cb) {\n  // will use a connection from a context\n  context.get('connection').query('update users ...', cb);\n};\n")),Object(r.b)("p",null,"Now if one of those ",Object(r.b)("inlineCode",{parentName:"p"},"if (err) throw err")," lines throw an error then the\ntransaction will be rolled back otherwise it will be commited after we dispose\nthe current domain with a ",Object(r.b)("inlineCode",{parentName:"p"},"domain.dispose()")," call — the only we thing we should\nnot forget to execute."),Object(r.b)("h2",null,"Connect middleware"),Object(r.b)("p",null,"The package also provides a middleware for a ",Object(r.b)("a",Object(o.a)({parentName:"p"},{href:"http://www.senchalabs.org/connect/"}),"Connect")," application:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{}),"...\napp.use(require('connect-domain')())\napp.use(context.middleware(lifecycle));\n... // any other middlewares goes here\napp.use(context.middlewareOnError(lifecycle));\n...\n")),Object(r.b)("p",null,"Which with the help of ",Object(r.b)("a",Object(o.a)({parentName:"p"},{href:"https://github.com/baryshev/connect-domain"}),"connect-domain")," creates a new domain for each request\nand manages its context."),Object(r.b)("h2",null,"About modularity"),Object(r.b)("p",null,"Note that using ",Object(r.b)("a",Object(o.a)({parentName:"p"},{href:"https://github.com/andreypopp/domain-context"}),"domain-context")," hurts modularity of your code — it will be\nusable only with the presence of domain with some specific context. It means\nthat this pattern isn't suitable for developing libraries. But, I think, it is\nquite useful for developing final applications to reduce boilerplate and so the\nnumber of possible bugs."))}u.isMDXComponent=!0},Rl4L:function(e,n,t){(window.__NEXT_P=window.__NEXT_P||[]).push(["/writings/2013-05-18-node-js-domain-local-storage",function(){var e=t("Ao4s");return{page:e.default||e}}])}},[["Rl4L","5d41","9da1"]]]);