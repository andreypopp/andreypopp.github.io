(window.webpackJsonp=window.webpackJsonp||[]).push([["e247"],{V3E2:function(e,n,t){"use strict";t.r(n),t.d(n,"title",function(){return c}),t.d(n,"default",function(){return p});var r=t("z3IF"),a=t("2Fjn"),o=(t("mXGw"),t("SAVP")),s=t("SGno"),c="RPC over WebSockets",i={title:c},l=s.a;function p(e){var n=e.components,t=Object(a.a)(e,["components"]);return Object(o.b)(l,Object(r.a)({},i,t,{components:n,mdxType:"MDXLayout"}),Object(o.b)("p",null,"Wouldn't be cool to use WebSockets as a transport for an RPC mechanism? Imagine\nif you can make any request to a server in your application not only through XHR\nbut also through persistent WebSocket connection."),Object(o.b)("p",null,"Let's see how we compose a solution almost in a minute by using ready made\nreusable tiny libraries. How do we achieve that? Using ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"http://nodejs.org/api/stream.html"}),"streams"),"."),Object(o.b)("p",null,"A stream is an amazingly efficient and composable abstraction for I/O. Below you\nwill see how we glue together several stream-based libraries to provide an RPC\non top of WebSockets."),Object(o.b)("h2",null,"RPC on top of Streams"),Object(o.b)("p",null,"The first library we need is ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"https://github.com/andreypopp/stream-rpc"}),"stream-rpc")," which provides an RPC mechanism on\ntop of arbitrary streams:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{}),"var rpc = require('stream-rpc');\n\nvar client = rpc()\nvar server = rpc({\n  handle: function(request, done) {\n    // process request\n    done(null, {msg: 'hello, ' + request.name + '!'});\n  });\n\nclient.pipe(server).pipe(client);\n\nclient.call({name: 'world'}, function(err, response) {\n  console.log(response.msg); // 'hello, world!'\n});\n")),Object(o.b)("p",null,"As you can see we created ",Object(o.b)("inlineCode",{parentName:"p"},"client")," and ",Object(o.b)("inlineCode",{parentName:"p"},"server")," streams and connected them\ndirectly to each other. But we are not required to connect them that way, we can\nplace ",Object(o.b)("inlineCode",{parentName:"p"},"client")," and ",Object(o.b)("inlineCode",{parentName:"p"},"server")," in different processes and even on different\nphysical machines and connect them through network."),Object(o.b)("h2",null,"JSON over streams"),Object(o.b)("p",null,"So we figured out how to do RPC over streams. Now if we want to put ",Object(o.b)("inlineCode",{parentName:"p"},"client")," and\n",Object(o.b)("inlineCode",{parentName:"p"},"server")," in different processes and interface over WebSockets then we need to\nserialize and deserialize data inside streams."),Object(o.b)("p",null,"Let's choose JSON as a serialization format and provide streams which can handle\nthe mechanics:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{}),"var through = require('through');\n\nvar serialize = function() {\n  return through(function(data) {\n    this.push(JSON.stringify(data));\n  });\n};\n\nvar deserialize = function() {\n  return through(function(data) {\n    this.push(JSON.parse(data));\n  });\n};\n")),Object(o.b)("p",null,"As you can see we used a tiny ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"https://github.com/dominictarr/through"}),"through")," library which allows to define streams\nwhich transform values inside."),Object(o.b)("h2",null,"RPC on top of WebSockets"),Object(o.b)("p",null,"The final step is to find a way to represent a WebSocket connection as a stream\nand connect our ",Object(o.b)("inlineCode",{parentName:"p"},"client")," and ",Object(o.b)("inlineCode",{parentName:"p"},"server")," streams together by the means of it."),Object(o.b)("p",null,"Luckily for us, there is ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"https://github.com/maxogden/websocket-stream"}),"websocket-stream")," library which provides exactly\nwhat we need â€” a WebSocket interaction modelled as a stream, suitable both for\nNode.js and in browser usage."),Object(o.b)("p",null,"On server we have:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{}),"var websocket = require('websocket-stream'),\n    rpc = require('stream-rpc'),\n    ws = require('ws'),\n    wss = new ws.Server({port: 3000}),\n    handle = function(request, done) {\n      // process request\n      done(null, {msg: 'hello, ' + request.name + '!'});\n    };\n\nwss.on('connection', function(ws) {\n  var sock = websocket(ws),\n      server = rpc({handle: handle});\n  server\n    .pipe(serialize())\n    .pipe(sock)\n    .pipe(deserialize())\n    .pipe(server);\n});\n")),Object(o.b)("p",null,"Now the client part which uses exactly the same libraries:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{}),"var websocket = require('websocket-stream'),\n    rpc = require('stream-rpc'),\n    sock = websocket('ws://localhost:3000'),\n    client = rpc();\n\nclient\n  .pipe(serialize())\n  .pipe(sock)\n  .pipe(deserialize())\n  .pipe(client);\n\nsock.on('open', function() {\n  client.call({name: 'andrey'}, function(err, response) {\n    console.log(response.msg); // 'hello, andrey!'\n  });\n});\n")),Object(o.b)("p",null,"These are the complete examples, you can try them and see how it works."),Object(o.b)("p",null,"As you can see, we can create a working solution using just a minimum amount of\ncode and sharing almost all of it between the server and the client."),Object(o.b)("p",null,"If you want to know more about streams in Node.js I can recommend you reading a\n",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"https://github.com/substack/stream-handbook"}),"stream handbook"),"."))}p.isMDXComponent=!0},WThd:function(e,n,t){(window.__NEXT_P=window.__NEXT_P||[]).push(["/writings/2013-05-21-rpc-over-websocket-the-easy-way",function(){var e=t("V3E2");return{page:e.default||e}}])}},[["WThd","5d41","9da1"]]]);