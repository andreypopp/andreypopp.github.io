(window.webpackJsonp=window.webpackJsonp||[]).push([["50d1"],{"3hcP":function(e,t,n){"use strict";n.r(t),n.d(t,"title",function(){return c}),n.d(t,"default",function(){return b});var a=n("z3IF"),o=n("2Fjn"),s=(n("mXGw"),n("SAVP")),l=n("SGno"),c="PostgreSQL's composite types",r={title:c},i=l.a;function b(e){var t=e.components,n=Object(o.a)(e,["components"]);return Object(s.b)(i,Object(a.a)({},r,n,{components:t,mdxType:"MDXLayout"}),Object(s.b)("p",null,"PostgreSQL has quite a decent type system although it isn't as expressive as the type systems modern programming languages (Haskell, Scala, ...) have."),Object(s.b)("p",null,"One of its features is ",Object(s.b)("em",{parentName:"p"},"composite types")," — it basically allows to group related\ncolumns into a single type declaration like this:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{}),"create type complex as (\n  r double,\n  i double,\n);\n")),Object(s.b)("p",null,"Now you can use type ",Object(s.b)("inlineCode",{parentName:"p"},"complex")," in functions, column definitions and\nanywhere else. But the interesting thing is how composite types relate to table\ndeclarations — the ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"http://www.postgresql.org/docs/9.1/static/rowtypes.html"}),"documentation")," states — \"whenever you create a table, a\ncomposite type is also automatically created, with the same name as the table,\nto represent the table's row type\". So, you can use table's composite type in\nfunctions too and that's great for encapsulation, whoa!"),Object(s.b)("p",null,"A small example follows — suppose we're Spotify or rdio and we like PostgreSQL and store music metadata there like this:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{}),"create table album (\n  id int,\n  title text,\n  can_stream bool,\n  can_sell bool,\n  ...\n);\n")),Object(s.b)("p",null,"Now we have a rule \"if we can't stream or sell album we shouldn't show it to a\nuser\". We can tediously write ",Object(s.b)("inlineCode",{parentName:"p"},"where can_sell or can_stream")," all over the code\nor just define a function"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{}),"create function can_show(album) returns bool\n  language sql\n  immutable strict\nas $$ select $1.can_stream or $1.can_sell; $$;\n")),Object(s.b)("p",null,"Nice, now to select first 10 albums we can show to a user we can write SQL query\nlike this"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{}),"select * from album where can_show(album) limit 10\n")),Object(s.b)("p",null,'and if we will want to change our rule of "when to show album to a user" — we\njust need to change ',Object(s.b)("inlineCode",{parentName:"p"},"can_show")," function definition."),Object(s.b)("p",null,"Naturally, there are downsides. For one, suppose we also have musical tracks' metadata stored in PostgreSQL in the similar fashion"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{}),"create table track (\n  id int,\n  album_id int,\n  can_stream bool,\n  can_sell bool,\n  ...\n);\n")),Object(s.b)("p",null,"and have exactly the same rule \"if we can't stream or sell track we shouldn't show\nit to a user\". The problem is we can't use the same function ",Object(s.b)("inlineCode",{parentName:"p"},"can_show")," because it\nonly operates on arguments which have ",Object(s.b)("inlineCode",{parentName:"p"},"album")," type. We can only copy-and-paste\nfunction declaration and change its argument type from ",Object(s.b)("inlineCode",{parentName:"p"},"album")," to ",Object(s.b)("inlineCode",{parentName:"p"},"track"),". it\nisn't a clean solution, it is?"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{}),"create function can_show(track) returns bool\n  language sql\n  immutable strict\nas $$ select $1.can_stream or $1.can_sell; $$;\n")),Object(s.b)("p",null,"Of course it isn't a problem if we have different rules for albums and tracks\nbut what if we don't?"),Object(s.b)("p",null,"One solution I see is to add ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"http://en.wikipedia.org/wiki/Structural_type_system"}),"structural types")," to PostgreSQL's type system,\nso you can declare ",Object(s.b)("inlineCode",{parentName:"p"},"can_show")," function in the following manner"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{}),"create function can_show(row(can_sell bool, can_stream bool, ...))\n  returns bool\n  language sql\n  immutable strict\nas $$ select $1.can_stream or $1.can_sell; $$;\n")),Object(s.b)("p",null,"You see, there's fancy type declaration ",Object(s.b)("inlineCode",{parentName:"p"},"row(can_sell bool, can_stream bool,\n...)")," which means ",Object(s.b)("em",{parentName:"p"},"any row which has can_sell and can_stream columns"),"."))}b.isMDXComponent=!0},"9c2s":function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/writings/2012-05-20-postgresqls-composite-types",function(){var e=n("3hcP");return{page:e.default||e}}])}},[["9c2s","5d41","9da1"]]]);