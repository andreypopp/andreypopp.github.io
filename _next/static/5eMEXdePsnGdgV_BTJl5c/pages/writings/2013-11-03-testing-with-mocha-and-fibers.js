(window.webpackJsonp=window.webpackJsonp||[]).push([["99b8"],{"0shn":function(e,n,t){(window.__NEXT_P=window.__NEXT_P||[]).push(["/writings/2013-11-03-testing-with-mocha-and-fibers",function(){var e=t("B4HV");return{page:e.default||e}}])},B4HV:function(e,n,t){"use strict";t.r(n),t.d(n,"title",function(){return r}),t.d(n,"default",function(){return u});var o=t("z3IF"),a=t("2Fjn"),s=(t("mXGw"),t("SAVP")),i=t("SGno"),r="Testing Node.js apps with Mocha and Fibers",c={title:r},b=i.a;function u(e){var n=e.components,t=Object(a.a)(e,["components"]);return Object(s.b)(b,Object(o.a)({},c,t,{components:n,mdxType:"MDXLayout"}),Object(s.b)("p",null,"While ",Object(s.b)("a",Object(o.a)({parentName:"p"},{href:"https://github.com/laverdet/node-fibers"}),"node-fibers")," seems not to be a popular way to develop software in\nNode-land (which is unfortunate), I think, it is quite handy and useful and you\nshould at least try to use it for writing tests for your apps."),Object(s.b)("p",null,"First, what's ",Object(s.b)("a",Object(o.a)({parentName:"p"},{href:"https://github.com/laverdet/node-fibers"}),"node-fibers"),"? It's a library which brings coroutines for\nNode.js. It is for Node.js as Fibers for Ruby, greenlets for Python, processes\nfor Erlang and goroutines for Go."),Object(s.b)("p",null,"In practice that means that you can write synchronously looking code which\nexecutes in an async way underneath. The library is pretty low-level and is not\nmeant to be used directly but rather through higher-level abstractions,\n",Object(s.b)("a",Object(o.a)({parentName:"p"},{href:"https://github.com/goodeggs/fibrous"}),"fibrous")," is one of those I like best. The example of an async reading from\nfilesystem using fibrous synchronous API:"),Object(s.b)("pre",null,Object(s.b)("code",Object(o.a)({parentName:"pre"},{}),"var fibrous = require('fibrous');\nvar fs = require('fs');\n\nfibrous.run(function() {\n  var content = fs.sync.readFile('README', 'utf8');\n  console.log(content); // outputs the content of README\n});\n")),Object(s.b)("p",null,"Note, that this is not like ",Object(s.b)("inlineCode",{parentName:"p"},"fs.readFileSync"),", it is completely non-blocking\ncall in a way that this doesn't block event loop but rather a single fiber which\nis created by ",Object(s.b)("inlineCode",{parentName:"p"},"fibrous.run")," function. So a lot of such calls can be executed\nconcurrently with almost no overhead on top of callbacks."),Object(s.b)("p",null,"Yes, it patches ",Object(s.b)("inlineCode",{parentName:"p"},"Object")," and ",Object(s.b)("inlineCode",{parentName:"p"},"Function")," to add ",Object(s.b)("inlineCode",{parentName:"p"},".sync")," property but that's\nworthwhile the easiness you get when adapting Node-style callback API to fiber\nbased API. In fact, you can use Node callbacks everywhere you like and only use\nfibers where necessary. Just use ",Object(s.b)("inlineCode",{parentName:"p"},".sync")," property on functions and objects to\nget a fiber API which fully reflects the original one."),Object(s.b)("p",null,"These all make fibrous (and fibers) very useful for writing tests for Node.js\napps. You don't usually want your apps/libs (especially open source) to depend\non such a \"magical\" thing as fibers but using it just for tests doesn't make so\nmuch pressure on you."),Object(s.b)("p",null,"I use fibers in combination with ",Object(s.b)("a",Object(o.a)({parentName:"p"},{href:"https://github.com/visionmedia/mocha"}),"mocha"),". For that you would need a version\nof mocha which is greater or equal to 1.14.0 otherwise you are not allowed to\nuse custom mocha UIs except for the bundled ones. You also need to install a\n",Object(s.b)("a",Object(o.a)({parentName:"p"},{href:"https://github.com/pulseio/mocha-fibers"}),"mocha-fibers")," UI for mocha which wraps ",Object(s.b)("inlineCode",{parentName:"p"},"it"),", ",Object(s.b)("inlineCode",{parentName:"p"},"before"),", ",Object(s.b)("inlineCode",{parentName:"p"},"beforeEach"),", ...\nblocks into fibers. It isn't yet on npm so you can install it from my ",Object(s.b)("a",Object(o.a)({parentName:"p"},{href:"https://github.com/andreypopp/mocha-fibers"}),"fork"),"\nwhich has the latest fixes. You also need fibrous package installed."),Object(s.b)("pre",null,Object(s.b)("code",Object(o.a)({parentName:"pre"},{}),"% npm install fibrous\n% npm install 'mocha@>=1.14.0'\n% npm install https://github.com/andreypopp/mocha-fibers.git\n")),Object(s.b)("p",null,"Then use the following command to run your test cases:"),Object(s.b)("pre",null,Object(s.b)("code",Object(o.a)({parentName:"pre"},{}),"% mocha --ui mocha-fibers --require fibrous ./tests.js\n")),Object(s.b)("p",null,"Now you can use fibrous API inside you test cases:"),Object(s.b)("pre",null,Object(s.b)("code",Object(o.a)({parentName:"pre"},{}),"var fs = require('fs');\n\ndescribe('my app', function() {\n\n  it('works', function() {\n    var contentA = fs.sync.readFile('./a');\n    var contentB = fs.sync.readFile('./b');\n    // ... do some assertions\n  });\n\n});\n")),Object(s.b)("p",null,"Of course, examples with ",Object(s.b)("inlineCode",{parentName:"p"},"fs")," are not quite interesting because ",Object(s.b)("inlineCode",{parentName:"p"},"fs")," module has\nsynchronous API which is suitable for use when writing tests. But you got the\nidea â€” you can execute synchronously any async function which accepts callback\nas it last argument by simply preprending ",Object(s.b)("inlineCode",{parentName:"p"},".sync")," suffix before."))}u.isMDXComponent=!0}},[["0shn","5d41","9da1"]]]);